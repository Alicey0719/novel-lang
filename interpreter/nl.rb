require "strscan"
require "optparse"
require 'pp'

class NovelLangSyntaxError < StandardError
end

class NovelLang
    @@KEYS = {
        "+" => :add,
        "-" => :sub,
        "*" => :mul,
        "/" => :div,
        "(" => :parn_L,
        ")" => :parn_R,
        "ü§î" => :branch,
        "üïë" => :loop,
        "‚õÑ" => :string,
        "üìù" => :std_in,
        "„Äå" => :std_out_L,
        "„Äç" => :std_out_R,
        "„Äê" => :var_L,
        "„Äë" => :var_R,
        "Ôºà" => :assignment_L,
        "Ôºâ" => :assignment_R,
        "‚Ä¶‚Ä¶" => :section,
        ">" => :greater_than,
        "<" => :less_than,
        "Ex-iT" => :exit,
    }
    @@KEYS_RE = "#{@@KEYS.map { |t| Regexp.escape(t[0]) }.join("|")}"
    #@@KEYS_RE = "[ü§îüïë‚õÑüìù„Äå„Äç„Äê„ÄëÔºàÔºâ><]|‚Ä¶‚Ä¶"
    @@RETURN_RE = '\n|\r\n'
    @@STR_RE = '[\w\p{Hiragana}\p{Katakana}\p{Han}]+'
    @@CALC_RE = '[\+\-\*\/\(\)]'
    @@EOP_RE = '\A\s*\z'
    @@FLOAT_STR = '\A[0-9]+\.[0-9]+\z'

    @@TOKEN_RE = "#{@@RETURN_RE}|#{@@KEYS_RE}|#{@@STR_RE}"

    def initialize
        # init
        STDOUT.sync = true
        STDIN.sync = true
        @nl_var_hash = Hash.new(nil)

        # option-parse
        op = OptionParser.new
        op.on("-d", "--debug", desk = "Debug mode.") { |v| @debug = true }
        op.parse!(ARGV)

        # running
        code = read_file(ARGV[0])
        run(code)        
    end

    private def run(text)
        p text if @debug

        text = text.gsub(/[\r\n]/, "")
        p text if @debug

        @sc = StringScanner.new(text)
        code_array = parse()

        print "\n" if @debug
        pp code_array if @debug
        print "\n" if @debug

        eval(code_array)
        p @nl_var_hash if @debug
        return
    end

    private def sentences()
        result = [:block]
        while s = sentence()
            result.push(s)
        end
        return result
    end

    private def sentence()
        if ret = eop()
            p "Sentence eop: [#{ret}]" if @debug
            return nil
        elsif ret = assignment()
            p "Sentence Assignment: [#{ret}]" if @debug
            return ret
        elsif ret = std_out()
            p "Sentence STD_OUT: [#{ret}]" if @debug
            return ret
        elsif ret = branch()
            p "Sentence branch: [#{ret}]" if @debug
            return ret
        elsif ret = loopers()
            p "Sentence loopers: [#{ret}]" if @debug
            return ret
        elsif ret = ex_it()
            p "Sentence ex-it: [#{ret}]" if @debug
            return ret
        else
            raise NovelLangSyntaxError, "Sentence Error: [#{ret}] Ë©≤ÂΩì„Åô„ÇãSentence„Åå„ÅÇ„Çä„Åæ„Åõ„Çì"
        end
    end

    private def loopers()
        result = [:loop]
        unless get_token() == :loop
            unget_token()
            return nil
            #raise NovelLangSyntaxError, "AssignmentError: not found '„Äê' "
        end

        unless ret = expression() #Êù°‰ª∂Âºè
            raise NovelLangSyntaxError, "loop Error: not found [Expression]"
        end
        result.push(ret)

        unless get_token() == :section
            raise NovelLangSyntaxError, "loop Error: not found '‚Ä¶‚Ä¶' "
        end

        unless ret = sentence() #„É´„Éº„ÉóÂÜÖÂÆπ
            #raise NovelLangSyntaxError, "loop Error: not found []"
        end
        result.push(ret)
    end    

    private def branch()
        result = [:branch]
        unless get_token() == :branch
            unget_token()
            return nil
            #raise NovelLangSyntaxError, "AssignmentError: not found '„Äê' "
        end
        unless ret = expression() #Êù°‰ª∂Âºè
            raise NovelLangSyntaxError, "branch Error: not found [Expression]"
        end
        result.push(ret)

        unless get_token() == :section
            raise NovelLangSyntaxError, "branch Error: not found '‚Ä¶‚Ä¶' "
        end

        unless ret = sentence() #Áúü„ÅÆ„Å®„Åç
            #raise NovelLangSyntaxError, "branch Error: not found []"
        end
        result.push(ret)

        unless get_token() == :section
            raise NovelLangSyntaxError, "branch Error: not found '‚Ä¶‚Ä¶' "
        end

        unless ret = sentence() #ÂÅΩ„ÅÆ„Å®„Åç
            #raise NovelLangSyntaxError, "branch Error: not found []"
        end
        result.push(ret)
    end

    private def std_out()
        result = [:std_out]
        unless get_token() == :std_out_L
            unget_token()
            return nil
            #raise NovelLangSyntaxError, "AssignmentError: not found '„Äê' "
        end

        unless ret = expression()
            raise NovelLangSyntaxError, "STD_OUT Error: not found [Expression]"
        end
        result.push(ret)

        unless get_token() == :std_out_R
            raise NovelLangSyntaxError, "STD_OUT Error: not found '„Äç' "
        end

        return result
    end

    private def eop()
        unless get_token() == nil
            unget_token()
            return nil
            #raise NovelLangSyntaxError, "AssignmentError: not found '„Äê' "
        end
        return :eop
    end

    private def ex_it()
        unless get_token() == :exit
            unget_token()
            return nil
            #raise NovelLangSyntaxError, "AssignmentError: not found '„Äê' "
        end
        return :exit
    end

    private def assignment()
        result = [:assignment]
        unless get_token() == :var_L
            unget_token()
            return nil
            #raise NovelLangSyntaxError, "AssignmentError: not found '„Äê' "
        end

        ret = get_token() #String(Â§âÊï∞Âêç)„ÅåÂ∏∞„Å£„Å¶„Åè„Çã„ÅØ„Åö
        unless ret.instance_of?(String)
            raise NovelLangSyntaxError, "AssignmentError: VarError[#{ret}]"
        end
        result.push([:var, ret])

        unless get_token() == :var_R
            raise NovelLangSyntaxError, "AssignmentError: not found '„Äë' "
        end

        unless get_token() == :assignment_L
            unget_token()
            return nil
            #raise NovelLangSyntaxError, "AssignmentError: not found 'Ôºà' "
        end

        ret = get_token()
        #std_in(‰Ωï„ÇÇ„Åó„Å™„ÅÑ)„ÅãÂºè„ÅãÊñáÂ≠óÂàó„Åå‰ª£ÂÖ•„Åï„Çå„Çã„ÅØ„Åö
        if ret == :string then #ÊñáÂ≠óÂàó
            ret = get_token()
            raise NovelLangSyntaxError, "AssignmentError: not found [‚õÑ]" unless get_token() == :string
        elsif ret != :std_in then #Âºè„ÅÆ„Å®„Åç„ÅÆÂá¶ÁêÜ
            unget_token() #exp„Åßget_token„Åô„Çã„Åü„ÇÅ‰∏ÄÊó¶unget„Åô„Çã
            unless ret = expression()
                raise NovelLangSyntaxError, "AssignmentError: not found [Expression]"
            end
        end
        result.push(ret)

        unless get_token() == :assignment_R
            raise NovelLangSyntaxError, "AssignmentError: not found 'Ôºâ' "
        end
        return result
    end


    private def eval(exp)
        #p exp
            if exp.instance_of?(Array)
            case exp[0]
            when :block
                exp.shift
                while b = exp.shift do
                    p "!!block!! #{b}" if @debug
                    eval(b)
                end
            when :add
                # add„ÅØÊñáÂ≠óÂàóÂä†ÁÆóOK
                begin
                    return eval(exp[1]) + eval(exp[2])
                rescue TypeError => e
                    return eval(exp[1]).to_s + eval(exp[2]).to_s
                end
            when :sub
                tmp1 = eval(exp[1])
                str_is_exception(tmp1)
                tmp2 = eval(exp[2])
                str_is_exception(tmp2)
                return tmp1 - tmp2
            when :mul
                tmp1 = eval(exp[1])
                str_is_exception(tmp1)
                tmp2 = eval(exp[2])
                str_is_exception(tmp2)
                return tmp1 * tmp2
            when :div
                tmp1 = eval(exp[1])
                str_is_exception(tmp1)
                tmp2 = eval(exp[2])
                str_is_exception(tmp2)
                raise NovelLangSyntaxError, "Division by zero error" if tmp2 == 0 #„Çº„É≠Èô§ÁÆó„Ç®„É©„Éº„Çè„Çà
                return tmp1 / tmp2
            when :assignment
                #p "a  #{exp}"
                return @nl_var_hash[eval(exp[1][1])] = eval(exp[2])
            when :var
                #p "var-eval #{exp} #{@nl_var_hash[exp[1]]}"
                return @nl_var_hash[exp[1]]
            when :std_out                
                print "#{eval(exp[1])}\n"
                p "#{eval(exp[1]).class}" if @debug
            when :branch
                f = eval(exp[1]).to_i
                if f.positive? then
                    return eval(exp[2])
                else
                    return eval(exp[3])
                end
            when :loop
                while true do
                    f = eval(exp[1]).to_i
                    unless f.positive? then
                        break
                    end
                    eval(exp[2])
                end
                return true
            end
        elsif exp == :std_in
            tmp = STDIN.gets.chomp
            if is_number?(tmp)
                return tmp.to_f if tmp =~ /#{@@FLOAT_STR}/
                return tmp.to_i
            end
            return tmp
        elsif exp == :exit
            escape(0)
        else
            return exp
        end
    end

    private def parse()
        return sentences()
    end

    ## Exp
    private def expression()
        result = term()
        token = get_token()
        while token == :add or token == :sub # or token == :assignment_L or token == :std_out_L
            result = [token, result, term()]
            token = get_token()
        end
        
        unget_token() 

        p "exp : #{result}" if @debug
        return result
    end

    ## Term
    private def term()
        result = factor()
        token = get_token()
        while token == :mul or token == :div
            result = [token, result, factor()]
            token = get_token()
        end
        
        unget_token()
        p "term: #{result}" if @debug
        return result
    end

    ## Fact
    private def factor()
        token = get_token()
        if token =~ /\d+/ #„Éà„Éº„ÇØ„É≥„Åå„É™„ÉÜ„É©„É´„Åã
            #„É™„ÉÜ„É©„É´
            result = token.to_i
            result = token.to_f if token =~ /#{@@FLOAT_STR}/ 
        elsif token == :parn_L
            result = expression()
            if get_token() != :parn_R # Èñâ„Åò„Ç´„ÉÉ„Ç≥„ÇíÂèñ„ÇäÈô§„Åè
                raise NovelLangSyntaxError, "SyntaxError ')'„Åå„ÅÇ„Çä„Åæ„Åõ„Çì"
            end
        elsif token == :var_L #Â§âÊï∞Èñ¢‰øÇ
            var = get_token()
            if var =~ /#{@@KEYS_RE}|#{@@RETURN_RE}|#{@@CALC_RE}/
                raise NovelLangSyntaxError, "SyntaxError Â§âÊï∞Âêç„ÅåÊ≠£„Åó„ÅèË¶èÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì"
            end

            result = [:var, var]           

            if get_token() != :var_R # Èñâ„Åò„Ç´„ÉÉ„Ç≥„ÇíÂèñ„ÇäÈô§„Åè
                raise NovelLangSyntaxError, "SyntaxError '„Äë'„Åå„ÅÇ„Çä„Åæ„Åõ„Çì"
            end
        else
            raise NovelLangSyntaxError, "Syntax error factor: '#{token}'"
        end
        p "fact: #{result}" if @debug
        return result
    end

    #-- util --
    # tokenÊìç‰Ωú
    private def get_token()
        if @sc.scan(/#{@@TOKEN_RE}/) #token?
            @before_scan = @sc[0] #eosÊôÇ„ÅÆunscanÁî®

            if @sc[0] =~ /#{@@KEYS_RE}/ #„Ç≠„Éº„ÇíËøî„Åô
                p @@KEYS[@sc[0]] if @debug
                return @@KEYS[@sc[0]]
            elsif @sc[0] =~ /#{@@RETURN_RE}/ #ÊîπË°å
                print "return\n\n" if @debug
            elsif @sc[0] =~ /#{@@STR_RE}/ #Ëã±Â≠ó„ÉªÊó•Êú¨Ë™û
                p @sc[0] if @debug
                return @sc[0]
            elsif @sc[0] =~ /#{@@EOP_RE}/ #„Ç≥„Éº„Éâ„ÅÆÁµÇÁ´Ø
                p "eop" if @debug
                return nil
            else
                p :bad_token if @debug
                return :bad_token
            end
        end
    end

    private def unget_token()
        unless @sc.eos?
            @sc.unscan()
        else
            raise NovelLangSyntaxError, "SyntaxError: fail token unget" if @before_scan.nil?
            @sc.string = @before_scan
            @before_scan = nil
            #p @sc
        end
        p "unget_token" if @debug
    end

    # ÊñáÂ≠óÂàó„ÅåÊï∞Â≠ó„ÅÆ„Åø„Å™„ÇâTrue
    private def is_number?(str)
        nil != (str =~ /\A[0-9.]+\z/)
    end

    # string„Åå„Åç„Åü„Çâexception
    private def str_is_exception(a)
        if a.is_a?(String)
            raise NovelLangSyntaxError, "Unexpected type error: string "
        end 
    end

    # read file2txt
    private def read_file(file_path)
        if file_path.nil?
            print("You need to specify the file to open.\n")
            exit 1
        end
        begin
            f = open(file_path, "r")
            res = f.read
            f.close
        rescue Errno::ENOENT
            print("File not found.\n")
            exit 1
        rescue
            print("File open error.\n")
            exit 1
        end
        return res
    end

    # exit
    private def escape(code = 0)
        exit(code)
    end
end

NovelLang.new()
